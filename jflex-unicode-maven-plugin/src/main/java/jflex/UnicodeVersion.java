/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * JFlex Unicode plugin                                                    *
 * Copyright (c) 2008 Steve Rowe <steve_rowe@users.sf.net>                 *
 *                                                                         *
 *                                                                         *
 * This program is free software; you can redistribute it and/or modify    *
 * it under the terms of the GNU General Public License. See the file      *
 * COPYRIGHT for more information.                                         *
 *                                                                         *
 * This program is distributed in the hope that it will be useful,         *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of          *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           *
 * GNU General Public License for more details.                            *
 *                                                                         *
 * You should have received a copy of the GNU General Public License along *
 * with this program; if not, write to the Free Software Foundation, Inc., *
 * 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA                 *
 *                                                                         *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

package jflex;

import java.net.URL;
import java.util.List;
import java.util.SortedMap;
import java.util.TreeMap;
import java.util.ArrayList;
import java.util.SortedSet;
import java.util.TreeSet;
import java.util.HashMap;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.io.IOException;
import java.io.BufferedReader;
import java.io.InputStreamReader;


/**
 * This class is instantiated for each version of Unicode for which data can
 * be found at unicode.org.  This class is responsible for parsing the following
 * Unicode data files:
 * <ul>
 *   <li>UnicodeData(-X.X.X).txt</li>
 *   <li>PropertyAliases(-X.X.X).txt</li>
 *   <li>PropertyValueAliases(-X.X.X).txt</li>
 *   <li>DerivedCoreProperties(-X.X.X).txt</li>
 *   <li>Scripts(-X.X.X).txt</li>
 *   <li>Blocks(-X.X.X).txt</li>
 *   <li>PropList(-X.X.X).txt</li>
 * </ul>
 * and for emitting (into the source file generated by
 * jflex-unicode-maven-plugin: UnicodeProperties.java) the set of Property
 * Values supported by this version of Unicode, as well as the corresponding
 * code point interval sets for each member of the Property Value set.
 */
class UnicodeVersion {

  /** Pattern for the full Unicode version */
  private final Pattern FULL_VERSION_PATTERN
    = Pattern.compile("(\\d+\\.\\d+)\\.\\d+");

  /** Pattern for the full Unicode version from the unicode data URL */
  private final Pattern FULL_VERSION_PATTERN_IN_URL
    = Pattern.compile("UnicodeData-(\\d+\\.\\d+\\.\\d+)\\.txt$");

  // v1.1: 00F8;LATIN SMALL LETTER O WITH STROKE;Ll;0;L;006F 0338;;;;N;LATIN SMALL LETTER O SLASH;;00D8;;00D8
  // v5.0: 00F8;LATIN SMALL LETTER O WITH STROKE;Ll;0;L;;;;;N;LATIN SMALL LETTER O SLASH;;00D8;;00D8
  // v5.0: 4DB5;<CJK Ideograph Extension A, Last>;Lo;0;L;;;;;N;;;;;
  //
  // Field  0: Code point
  // Field  1: Name
  // Field  2: General Category property value
  // Field 12: Simple uppercase mapping
  // Field 13: Simple lowercase mapping
  // Field 14: Simple titlecase mapping
  /** Pattern to capture data from UnicodeData(-X.X.X).txt */
  private static final Pattern UNICODE_DATA_LINE_PATTERN = Pattern.compile
    ("^([^;]*);(?:([^;]*,\\s*Last>)|[^;]*);([^;]*)(?:;[^;]*){9};([^;]*);([^;]*);([^;]*)");

  // v2.0: 0080; 00FF; Latin-1 Supplement
  // v3.1: 0080..00FF; Latin-1 Supplement
  /** Pattern to capture data from Blocks(-X.X.X).txt. */
  private static final Pattern BLOCKS_LINE_PATTERN = Pattern.compile
    ("^([0-9A-Fa-f]{4,6})(?:\\.\\.|;\\s*)([0-9A-Fa-f]{4,6});\\s*(.+)");

  // Scripts-3.1.0.txt: 0041..005A    ; LATIN # L&  [26] LATIN CAPITAL LETTER A..LATIN CAPITAL LETTER Z
  /**
   * Pattern to capture data from Scripts(-X.X.X).txt and
   * DerivedCoreProperties(-X.X.X).txt.
   */
  private static final Pattern NAMED_INTERVAL_LINE_PATTERN = Pattern.compile
    ("^([0-9A-Fa-f]{4,6})(?:\\.\\.([0-9A-Fa-f]{4,6}))?\\s*;\\s*([^#]+)");

  // v3.2: gc ; L         ; Letter                           # Ll | Lm | Lo | Lt | Lu
  // v3.2: sc ; Arab      ; Arabic
  /** Pattern to capture data from PropertyValueAliases(-X.X.X).txt. */
  private static final Pattern PROPERTY_VALUE_ALIAS_LINE_PATTERN
    = Pattern.compile("^(?:gc\\s*;\\s*(\\S+)\\s*;\\s*(\\S+)"
                      +  "|sc\\s*;\\s*(\\S+)\\s*;\\s*(\\S+))");

  // v3.2: Alpha     ; Alphabetic
  /** Pattern to capture data from PropertyAliases(-X.X.X).txt. */
  private static final Pattern PROPERTY_ALIAS_LINE_PATTERN
    = Pattern.compile("^(\\S+)\\s*;\\s*(\\S+)");

  // v3.2: 0009..000D    ; White_space # Cc   [5] <control>..<control>
  // v3.2: 0020          ; White_Space # Zs       SPACE
  // v2.0: Property dump for: 0x10000004 (White space)
  // v2.0: 0000
  // v2.0: 0009..000D  (5 chars)
  private static final Pattern PROP_LIST_LINE_PATTERN = Pattern.compile
    ("^(?:([\\da-fA-F]{4,6})(?:..([\\da-fA-F]{4,6}))?(?:\\s*;\\s*(\\S+))?"
     + "|Property dump for: 0x[\\dA-Fa-f]+\\s*\\(([^)]+)\\))");


  /** Pattern used to normalize property value identifiers */
  private static final Pattern WORD_SEP_PATTERN = Pattern.compile("[-_\\s]");

  /**
   * Pattern used to find property name prefixes, e.g. "Script" in 
   * "Script=Latin".
   */
  private static final Pattern PROPERTY_PREFIX_PATTERN
    = Pattern.compile("^([^=]+)=(.*)");

  /**
   * The number of code point ranges to output per line in
   * UnicodeProperties.java.
   */
  private static final int INTERVALS_PER_LINE = 4;

  /**
   * The number of alias/target property value pairs to output per line in
   * UnicodeProperties.java.
   */
  private static final int PROPERTY_VALUE_ALIAS_MAPPINGS_PER_LINE = 2;

  /**
   * The number of property values to output per line in UnicodeProperties.java.
   */
  int PROPERTY_VALUES_PER_LINE = 6;


  /**
   * The number of caseless match partitions to output per line in
   * UnicodeProperties.java.
   */
  private static final int CASELESS_MATCH_PARTITIONS_PER_LINE = 3;


  /** Unicode version X.X.X */
  String majorMinorUpdateVersion;

  /** Unicode version X.X */
  String majorMinorVersion;

  /** The greatest code point listed in UnicodeData(-X.X.X).txt */
  int maximumCodePoint;

  /**
   * Maps Unicode property values to the associated set of
   * code point ranges.
   */
  SortedMap<String,List<Interval>> propertyValueIntervals
    = new TreeMap<String,List<Interval>>();

  /** Stores property value aliases. */
  SortedMap<String,String> propertyValueAliases = new TreeMap<String,String>();

  /**
   * A set of code point space partitions, each containing at least two
   * caselessly equivalent code points.
   */
  Map<Integer,SortedSet<Integer>> caselessMatchPartitions
    = new HashMap<Integer,SortedSet<Integer>>();

  /** The maximum size of the partitions in {@link #caselessMatchPartitions}. */
  int caselessMatchPartitionSize = 0;

  /**
   * Instantiates a container for versioned Unicode data.
   *
   * @param version The Unicode version, either in form "X.X.X" or "X.X".
   * @param unicodeDataURL The URL to the UnicodeData(-X.X.X).txt file for this
   *  version.
   * @param propertyAliasesURL The URL to the PropertyAliases(-X.X.X).txt file
   *  for this version.
   * @param propertyValueAliasesURL The URL to the
   *  PropertyValueAliases(-X.X.X).txt file for this version.
   * @param derivedCorePropertiesURL The URL to the
   *  DerivedCoreProperties(-X.X.X).txt file for this version.
   * @param scriptsURL The URL to the Scripts(-X.X.X).txt file for this version.
   * @param blocksURL The URL to the Blocks(-X.X.X).txt file for this version.
   * @param propListURL The URL to the PropList(-X.X.X).txt file for this
   *  version.
   * @throws IOException If there is a problem fetching or parsing
   *  UnicodeData(-X.X.X).txt
   */
  UnicodeVersion(String version, URL unicodeDataURL, URL propertyAliasesURL,
                 URL propertyValueAliasesURL, URL derivedCorePropertiesURL,
                 URL scriptsURL, URL blocksURL, URL propListURL)
    throws IOException {

    setVersions(version, unicodeDataURL);
    
    parseUnicodeData(unicodeDataURL);  // Should be first - sets max code point

    if (null != propListURL) {
      parsePropList(propListURL);
    }
    if (null != derivedCorePropertiesURL) {
      parseDerivedCoreProperties(derivedCorePropertiesURL);
    }
    if (null != scriptsURL) {
      parseScripts(scriptsURL);
    }
    if (null != blocksURL) {
      parseBlocks(blocksURL);
    }
    if (null != propertyValueAliasesURL) { // Must be second-to-last
      parsePropertyValueAliases(propertyValueAliasesURL);
    }
    if (null != propertyAliasesURL) {      // Must be last
      parsePropertyAliases(propertyAliasesURL);
    }
  }

  /**
   * Fills in majorMinorVersion and majorMinorUpdateVersion based on the passed
   * in version string.
   *
   * @param version The Unicode version, in form "X.X.X" or "X.X".
   * @param unicodeDataURL The URL at which UnicodeData(-X.X.X).txt is located.
   */
  private void setVersions(String version, URL unicodeDataURL) {
    Matcher matcher = FULL_VERSION_PATTERN.matcher(version);
    if (matcher.matches()) {
      majorMinorUpdateVersion = matcher.group(0);
      majorMinorVersion = matcher.group(1);
    } else {
      majorMinorVersion = version;
      matcher = FULL_VERSION_PATTERN_IN_URL.matcher(unicodeDataURL.toString());
      if (matcher.find()) {
        majorMinorUpdateVersion = matcher.group(1);
      }
    }
  }

  /**
   * Fetches Blocks(-X.X.X).txt from the URL supplied in the constructor,
   * storing the code point ranges in {@link #propertyValueIntervals}.
   *
   * @param url The URL at which Blocks(-X.X.X).txt is located.
   * @throws IOException If there is a problem fetching or parsing
   *  Blocks(-X.X.X).txt.
   */
  private void parseBlocks(URL url) throws IOException {
    BufferedReader reader = new BufferedReader
      (new InputStreamReader(url.openStream(), "UTF-8"));
    String line;
    int lastEndCodePoint = -1;
    while (null != (line = reader.readLine())) {
      Matcher matcher = BLOCKS_LINE_PATTERN.matcher(line);
      if (matcher.find()) {
        int startCodePoint = Integer.parseInt(matcher.group(1), 16);
        int endCodePoint = Integer.parseInt(matcher.group(2), 16);
        String blockName = matcher.group(3);
        if (startCodePoint > lastEndCodePoint + 1) {
          // Blocks not explicitly mentioned get the "No_Block" designation
          addInterval
            ("Block=No_Block", lastEndCodePoint + 1, startCodePoint - 1);
        }
        addInterval("Block=" + blockName, startCodePoint, endCodePoint);
        lastEndCodePoint = endCodePoint;
      }
    }
    addInterval("Block=No_Block", lastEndCodePoint+1, maximumCodePoint);
  }

  /**
   * Fetches Scripts(-X.X.X).txt from the URL supplied in the constructor,
   * storing the code point ranges in {@link #propertyValueIntervals}.
   *
   * @param url The URL at which Scripts(-X.X.X).txt is located.
   * @throws IOException If there is a problem fetching or parsing
   *  Scripts(-X.X.X).txt.
   */
  private void parseScripts(URL url) throws IOException {
    BufferedReader reader = new BufferedReader
      (new InputStreamReader(url.openStream(), "UTF-8"));
    String line;
    SortedSet<Interval> intervals = new TreeSet<Interval>();

    // Scripts(-X.X.X).txt groups together intervals that belong to the same
    // script.  In order to discover unassigned intervals, the intervals are
    // first sorted according to their starting code point, and then intervals
    // are added, with gaps assigned to "Unknown".

    // First, sort the assigned intervals, so that gaps are apparent
    while (null != (line = reader.readLine())) {
      Matcher matcher = NAMED_INTERVAL_LINE_PATTERN.matcher(line);
      if (matcher.find()) {
        int start = Integer.parseInt(matcher.group(1), 16);
        int end = null == matcher.group(2)
                  ? start : Integer.parseInt(matcher.group(2), 16);
        String name = matcher.group(3);
        intervals.add(new Interval(start, end, name));
      }
    }
    reader.close();

    // Second, add intervals, assigning "Unknown" to the gaps.
    int prevEnd = -1;
    int prevStart = -1;
    String prevName = "";
    for (Interval interval : intervals) {
      if (interval.start > prevEnd + 1) {
        // Unassigned code points get the "Unknown" designation.
        addInterval("Unknown", prevEnd + 1, interval.start - 1);
      }
      if (prevEnd == -1) {
        prevStart = interval.start;
        prevName = interval.name;
      } else {
        if (interval.start > prevEnd + 1
            || ! interval.name.equals(prevName)) {
          addInterval(prevName, prevStart, prevEnd);
          addPropertyValueAlias("Script=" + prevName, prevName);
          addPropertyValueAlias("sc=" + prevName, prevName);
          prevStart = interval.start;
          prevName = interval.name;
        }
      }
      prevEnd = interval.end;
    }
    // Add final Unkown interval
    addInterval("Unknown", prevEnd + 1, maximumCodePoint);
    addPropertyValueAlias("Script=Unknown", "Unknown");

    // Add final named interval
    addInterval(prevName, prevStart, prevEnd);
    addPropertyValueAlias("Script=" + prevName, prevName);
    addPropertyValueAlias("sc=" + prevName, prevName);
  }

  /**
   * Fetches DerivedCoreProperties(-X.X.X).txt from the URL supplied in the
   * constructor, storing the code point ranges in
   * {@link #propertyValueIntervals}.
   *
   * @param url The URL at which DerivedCoreProperties(-X.X.X).txt is located.
   * @throws IOException If there is a problem fetching or parsing
   *  DerivedCoreProperties(-X.X.X).txt.
   */
  private void parseDerivedCoreProperties(URL url) throws IOException {
    BufferedReader reader = new BufferedReader
      (new InputStreamReader(url.openStream(), "UTF-8"));
    String line;
    int prevStart = -1;
    int prevEnd = -1;
    String prevName = "";
    while (null != (line = reader.readLine())) {
      Matcher matcher = NAMED_INTERVAL_LINE_PATTERN.matcher(line);
      if (matcher.find()) {
        int start = Integer.parseInt(matcher.group(1), 16);
        int end = null == matcher.group(2)
                  ? start : Integer.parseInt(matcher.group(2), 16);
        String name = matcher.group(3);

        if (prevEnd == -1) {
          prevStart = start;
          prevName = name;
        } else if (start > prevEnd + 1 || ! name.equals(prevName)) {
          addInterval(prevName, prevStart, prevEnd);
          prevStart = start;
          prevName = name;
        }
        prevEnd = end;
      }
    }
    reader.close();

    // Handle the final interval
    addInterval(prevName, prevStart, prevEnd);
  }

  /**
   * Fetches PropertyValueAliases(-X.X.X).txt from the URL supplied in the
   * constructor, storing aliases in {@link #propertyValueAliases}.
   *
   * @param url The URL at which PropertyValueAliases(-X.X.X).txt is located.
   * @throws IOException If there is a problem fetching or parsing
   *  PropertyValueAliases(-X.X.X).txt.
   */
  private void parsePropertyValueAliases(URL url) throws IOException {
    BufferedReader reader = new BufferedReader
      (new InputStreamReader(url.openStream(), "UTF-8"));
    String line;
    while (null != (line = reader.readLine())) {
      // At this point, we only recognize general category and script property
      // value aliases.
      Matcher matcher = PROPERTY_VALUE_ALIAS_LINE_PATTERN.matcher(line);
      if (matcher.find()) {
        String genCatPropValueShortName = matcher.group(1);
        if (null != genCatPropValueShortName) {
          String genCatPropValueLongName = matcher.group(2);
          // The short name appears in UnicodeData(-X.X.X).txt, so it serves as
          // the target property value.
          addPropertyValueAlias(genCatPropValueLongName,
                                genCatPropValueShortName);
          addPropertyValueAlias("General_Category=" + genCatPropValueLongName,
                                genCatPropValueShortName);
          addPropertyValueAlias("gc=" + genCatPropValueLongName,
                                genCatPropValueShortName);
          addPropertyValueAlias("gc=" + genCatPropValueShortName,
                                genCatPropValueShortName);
        } else {
          String scriptPropValueShortName = matcher.group(3);
          String scriptPropValueLongName = matcher.group(4);
          // The long name appears in Scripts.txt, so it serves as the target.
          addPropertyValueAlias(scriptPropValueShortName,
                                scriptPropValueLongName);
          addPropertyValueAlias("Script=" + scriptPropValueShortName,
                                scriptPropValueLongName);
          addPropertyValueAlias("sc=" + scriptPropValueShortName,
                                scriptPropValueLongName);
          addPropertyValueAlias("sc=" + scriptPropValueLongName,
                                scriptPropValueLongName);
        }
      }
    }
  }

  /**
   * Fetches PropertyAliases(-X.X.X).txt from the URL supplied in the constructor,
   * storing aliases in {@link #propertyValueAliases}.
   *
   * @param url The URL at which PropertyAliases(-X.X.X).txt is located.
   * @throws IOException If there is a problem fetching or parsing
   *  PropertyAliases(-X.X.X).txt.
   */
  private void parsePropertyAliases(URL url) throws IOException {
    BufferedReader reader = new BufferedReader
      (new InputStreamReader(url.openStream(), "UTF-8"));
    String line;
    Map<String,String> long2shortNameMap = new HashMap<String,String>();
    while (null != (line = reader.readLine())) {
      Matcher matcher = PROPERTY_ALIAS_LINE_PATTERN.matcher(line);
      if (matcher.find()) {
        String shortPropName = normalize(matcher.group(1));
        String longPropName = normalize(matcher.group(2));
        long2shortNameMap.put(normalize(longPropName), normalize(shortPropName));
      }
    }
    reader.close();

    for (String propertyValue : propertyValueIntervals.keySet()) {
      String shortPropName = long2shortNameMap.get(propertyValue);
      if (null != shortPropName) {
        addPropertyValueAlias(shortPropName, propertyValue);
      } else {
        Matcher matcher = PROPERTY_PREFIX_PATTERN.matcher(propertyValue);
        if (matcher.matches()) {
          String propertyPrefix = matcher.group(1);
          String propertyValueSuffix = matcher.group(2);
          shortPropName = long2shortNameMap.get(propertyPrefix);
          if (null != shortPropName) {
            addPropertyValueAlias(shortPropName + "=" + propertyValueSuffix,
                                  propertyValue);
          }
        }
      }
    }
  }

  /**
   * Fetches PropList(-X.X.X).txt from the URL supplied in the constructor,
   * storing the code point ranges in {@link #propertyValueIntervals}.
   *
   * @param url The URL at which PropList(-X.X.X).txt is located.
   * @throws IOException If there is a problem fetching or parsing
   *  PropList(-X.X.X).txt.
   */
  private void parsePropList(URL url) throws IOException {
    BufferedReader reader = new BufferedReader
      (new InputStreamReader(url.openStream(), "UTF-8"));
    String line;
    String propName = "";
    String prevPropName = "";
    int prevStart = -1;
    int prevEnd = -1;
    boolean archaicFormat = false; // Unicode 2.0, 2.1 & 3.0 have archaic format
    while (null != (line = reader.readLine())) {
      Matcher matcher = PROP_LIST_LINE_PATTERN.matcher(line);
      if (matcher.find()) {
        String archaicFormatPropName = matcher.group(4);
        if (null != archaicFormatPropName && archaicFormatPropName.length() > 0) {
          propName = archaicFormatPropName;
          archaicFormat = true;
          if (prevEnd != -1) {
            addInterval(prevPropName, prevStart, prevEnd);
          }
          prevPropName = propName;
          prevStart = -1;
          prevEnd = -1;
        } else {
          int start = -1;
          if (null != matcher.group(1) && matcher.group(1).length() > 0)
            start = Integer.parseInt(matcher.group(1), 16);
          int end = null != matcher.group(2) && matcher.group(2).length() > 0
                    ? Integer.parseInt(matcher.group(2), 16) : start;
          if (archaicFormat) {
            if (prevEnd == -1) {
              prevStart = start;
            } else if (start > prevEnd + 1) {
              addInterval(propName, prevStart, prevEnd);
              prevStart = start;
            }
            prevEnd = end;
          } else {
            if (null != matcher.group(3) && matcher.group(3).length() > 0)
              propName = matcher.group(3);

            if (prevEnd == -1) {
              prevStart = start;
              prevPropName = propName;
            } else if (start > prevEnd + 1 || ! propName.equals(prevPropName)) {
              addInterval(prevPropName, prevStart, prevEnd);
              prevStart = start;
              prevPropName = propName;
            }
            prevEnd = end;
          }
        }
      }
    }
    reader.close();

    // Handle the final interval
    addInterval(prevPropName, prevStart, prevEnd);
  }
  /**
   * Fetches UnicodeData(-X.X.X).txt from the URL supplied in the constructor,
   * storing the code point ranges in {@link #propertyValueIntervals}, and
   * storing caseless equivalence classes in {@link #caselessMatchPartitions}.
   *
   * @param url The URL at which UnicodeData(-X.X.X).txt is located.
   * @throws IOException If there is a problem fetching or parsing
   *  UnicodeData(-X.X.X).txt.
   */
  private void parseUnicodeData(URL url) throws IOException {
    BufferedReader reader = new BufferedReader
      (new InputStreamReader(url.openStream(), "UTF-8"));
    String line;
    int startCodePoint = -1;
    int prevCodePoint = 0;
    int assignedStartCodePoint = -1;
    int assignedEndCodePoint = -1;
    String prevGenCatPropValue = "";
    while (null != (line = reader.readLine())) {
      Matcher matcher = UNICODE_DATA_LINE_PATTERN.matcher(line);
      if (matcher.find()) {
        int codePoint = Integer.parseInt(matcher.group(1), 16);
        boolean isLastInRange = (null != matcher.group(2));
        String genCatPropValue = matcher.group(3);
        String uppercaseMapping = matcher.group(4);
        String lowercaseMapping = matcher.group(5);
        String titlecaseMapping = matcher.group(6);
        addCaselessMatches
          (codePoint, uppercaseMapping, lowercaseMapping, titlecaseMapping);

        if (assignedStartCodePoint == -1) {
          assignedStartCodePoint = startCodePoint;
        } else if (codePoint > assignedEndCodePoint + 1 && ! isLastInRange) {
          addInterval("Assigned", assignedStartCodePoint, assignedEndCodePoint);
          addInterval("Cn", assignedEndCodePoint + 1, codePoint - 1);
          assignedStartCodePoint = codePoint;
        }
        assignedEndCodePoint = codePoint;

        if (startCodePoint != -1
            && prevGenCatPropValue.length() > 0
            && (((codePoint > prevCodePoint + 1) && ! isLastInRange)
                || ! genCatPropValue.equals(prevGenCatPropValue))) {
          addInterval(prevGenCatPropValue, startCodePoint, prevCodePoint);
          addPropertyValueAlias("General_Category=" + prevGenCatPropValue,
                                prevGenCatPropValue);
          addPropertyValueAlias("gc=" + prevGenCatPropValue,
                                prevGenCatPropValue);
          startCodePoint = -1;
        }
        if (genCatPropValue.length() > 0 && startCodePoint == -1) {
          startCodePoint = codePoint;
        }
        prevCodePoint = codePoint;
        prevGenCatPropValue = genCatPropValue;
      }
    }
    // Handle the final interval, if there is one
    if (startCodePoint != -1 && prevGenCatPropValue.length() > 0) {
      addInterval(prevGenCatPropValue, startCodePoint, prevCodePoint);
    }

    // Handle the final Assigned interval
    addInterval("Assigned", assignedStartCodePoint, assignedEndCodePoint);

    // Round max code point up to end-of-plane.
    maximumCodePoint = ((prevCodePoint + 0x800) & 0xFFF000) - 1;

    // Handle the final Unassigned (Cn) interval, if any
    if (assignedEndCodePoint < maximumCodePoint) {
      addInterval("Cn", assignedEndCodePoint + 1, maximumCodePoint);
    }
  }

  /**
   * Grows the partition containing the given codePoint and its caseless
   * equivalents, if any, to include all of them.
   *
   * @param codePoint The code point to include in a caselessly equivalent
   *  partition
   * @param uppercaseMapping A hex String representation of the uppercase
   *  mapping of codePoint, or null if there isn't one
   * @param lowercaseMapping A hex String representation of the lowercase
   *  mapping of codePoint, or null if there isn't one
   * @param titlecaseMapping A hex String representation of the titlecase
   *  mapping of codePoint, or null if there isn't one
   */
  private void addCaselessMatches(int codePoint, String uppercaseMapping,
                                  String lowercaseMapping,
                                  String titlecaseMapping) {
    if ((null != uppercaseMapping && uppercaseMapping.length() > 0)
        || (null != lowercaseMapping && lowercaseMapping.length() > 0)
        || (null != titlecaseMapping && titlecaseMapping.length() > 0)) {

      Integer upper = null;
      if (null != uppercaseMapping && uppercaseMapping.length() > 0)
        upper = Integer.valueOf(uppercaseMapping, 16);
      else
        uppercaseMapping = null;

      Integer lower = null;
      if (null != lowercaseMapping && lowercaseMapping.length() > 0)
        lower = Integer.valueOf(lowercaseMapping, 16);
      else
        lowercaseMapping = null;

      Integer title = null;
      if (null != titlecaseMapping && titlecaseMapping.length() > 0)
        title = Integer.valueOf(titlecaseMapping, 16);
      else
        titlecaseMapping = null;

      SortedSet<Integer> partition = caselessMatchPartitions.get(codePoint);
      if (null == partition) {
        if (null != uppercaseMapping)
          partition = caselessMatchPartitions.get(upper);
        if (null == partition && null != lowercaseMapping)
          partition = caselessMatchPartitions.get(lower);
        if (null == partition && null != titlecaseMapping)
          partition = caselessMatchPartitions.get(title);
        if (null == partition) {
          partition = new TreeSet<Integer>();
        }
      }
      partition.add(codePoint);
      caselessMatchPartitions.put(codePoint, partition);
      
      if (null != uppercaseMapping) {
        partition.add(upper);
        caselessMatchPartitions.put(upper, partition);
      }
      if (null != lowercaseMapping) {
        partition.add(lower);
        caselessMatchPartitions.put(lower, partition);
      }
      if (null != titlecaseMapping) {
        partition.add(title);
        caselessMatchPartitions.put(title, partition);
      }

      if (partition.size() > caselessMatchPartitionSize) {
        caselessMatchPartitionSize = partition.size();
      }
    }
  }

  /**
   * Given a property value, and starting and ending code points, adds the
   * interval to the {@link #propertyValueIntervals} map.
   *
   * @param propValue The property value, e.g. "Lu".
   * @param startCodePoint The first code point in the interval.
   * @param endCodePoint The last code point in the interval.
   */
  private void addInterval(String propValue,
                           int startCodePoint, int endCodePoint) {
    String origPropValue = propValue;
    propValue = normalize(propValue);
    if (propValue.length() == 0) {
      System.err.println("UnicodeVersion.addInterval(): origPropValue: '"
                         + origPropValue + "'  start: " + startCodePoint
                         + "  end: " + endCodePoint);
      throw new RuntimeException();
    }
    List<Interval> intervals = propertyValueIntervals.get(propValue);
    if (null == intervals) {
      intervals = new ArrayList<Interval>();
      propertyValueIntervals.put(propValue, intervals);
    }
    // UnicodeData-1.1.5.txt does not list the end point for the Unified Han
    // range (starting point is listed as U+4E00).  This is U+9FFF according
    // to <http://unicode.org/Public/TEXT/OLDAPIX/CHANGES.TXT>:
    //
    //    U+4E00 ^ U+9FFF		20,992	I-ZONE Ideographs
    //
    // U+4E00 is listed in UnicodeData-1.1.5.txt as having the "Lo" property
    // value, as are the previous code points, so to include
    // [ U+4E00 - U+9FFF ], this interval should be extended to U+9FFF.
    if (endCodePoint == 0x4E00 && majorMinorVersion.equals("1.1")) {
      endCodePoint = 0x9FFF;
    }
    intervals.add(new Interval(startCodePoint, endCodePoint));
  }

  /**
   * Adds the given mapping to {@link #propertyValueAliases}.
   *
   * @param alias The property value alias
   * @param propertyValue The target property value
   */
  private void addPropertyValueAlias(String alias, String propertyValue) {
    propertyValueAliases.put(normalize(alias), normalize(propertyValue));
  }


  /**
   * Emits an int declaration and definition for the maximum code point listed
   * for this version in UnicodeData(-X.X.X).txt.
   *
   * @param builder Where to emit the maximum code point.
   */
  void emitMaximumCodePoint(StringBuilder builder) {
    builder.append("  private static final int maximumCodePoint")
      .append(getVersionSuffix()).append(" = 0x")
      .append(Integer.toString(maximumCodePoint, 16)).append(";\n");
  }

  /**
   * Emits an array declaration and definition for the set of property values
   * supported by this version of Unicode.
   *
   * @param builder Where to emit the property values array.
   */
  void emitPropertyValuesArray(StringBuilder builder) {
    builder.append("  private static final String[] propertyValues")
      .append(getVersionSuffix()).append("\n    = { ");
    int item = 0;
    for (String genCatPropValue : propertyValueIntervals.keySet()) {
      if (++item == PROPERTY_VALUES_PER_LINE) {
        builder.append(",\n        ");
        item = 1;
      } else if (item > 1) {
        builder.append(", ");
      }
      builder.append("\"").append(genCatPropValue).append("\"");
    }
    builder.append(" };\n");
  }

  /**
   * Emits an array declaration and definition for the set of code point ranges
   * in this version of Unicode, corresponding to and in the same order as the
   * array of property values emitted in
   * {@link #emitPropertyValuesArray(StringBuilder)}.
   * <p/>
   * Note that String form is required for the amount of data associated with
   * the existing Unicode versions - when coded as static two-dimensional arrays
   * of int, the Java byte compiler complains that "code too large".  This is
   * apparently due to size limits in the specification for Java .class format.
   *
   * @param builder Where to emit the intervals array
   */
  void emitIntervalsArray(StringBuilder builder) {
    builder.append("  private static final String[] intervals")
      .append(getVersionSuffix()).append(" = {\n");

    boolean isFirst = true;
    for (SortedMap.Entry<String,List<Interval>> entry
        : propertyValueIntervals.entrySet()) {
      String propertyValue = entry.getKey();
      List<Interval> intervals = entry.getValue();
      if (isFirst) {
        isFirst = false;
      } else {
        builder.append(",\n");
      }
      builder.append("    // Unicode ").append(majorMinorVersion)
        .append(" property value: {").append(propertyValue)
        .append("}\n");
      int count = 0;
      boolean isFirstIntervalLine = true;
      for (Interval interval : intervals) {
        if (++count > INTERVALS_PER_LINE) {
          builder.append("\n");
          count = 1;
        }
        if (count == 1) {
          builder.append(isFirstIntervalLine ? "        \"" : "      + \"");
        } else {
          builder.append("+\"");
        }
        isFirstIntervalLine = false;
        emitEscapedUTF16Char(builder, interval.start);
        emitEscapedUTF16Char(builder, interval.end);
        builder.append("\"");
      }
    }
    builder.append("  };\n");
  }

  /**
   * Emits an array declaration and definition of alternating key/value mappings
   * from property value aliases to target property values.
   *
   * @param builder Where to emit the intervals array
   */
  void emitPropertyValueAliasesArray(StringBuilder builder) {
    builder.append("  private static final String[] propertyValueAliases")
      .append(getVersionSuffix()).append(" = {\n        ");

    int count = 0;
    boolean isFirstLine = true;
    for (SortedMap.Entry<String,String> entry : propertyValueAliases.entrySet()) {
      if (++count > PROPERTY_VALUE_ALIAS_MAPPINGS_PER_LINE) {
        builder.append(",\n        ");
        count = 1;
      } else if ( ! isFirstLine) {
        builder.append(",   ");
      } else {
        isFirstLine = false;
      }
      String alias = entry.getKey();
      String propertyValue = entry.getValue();
      builder.append("\"").append(alias).append("\", \"").append(propertyValue)
        .append("\"");
    }
    builder.append("\n  };\n");
  }

  /**
   * Emits a constant assigned the size of each partition record (the maximum
   * partition size) and a string representing a sequence of fixed-length
   * partition records.  For partitions smaller than the maximum size, the
   * unused fields are populated with \u0000.
   *
   * @param builder Where to emit the caseless match partitions
   */
  void emitCaselessMatchPartitions(StringBuilder builder) {
    builder.append("  private static final int caselessMatchPartitionSize")
      .append(getVersionSuffix()).append(" = ")
      .append(caselessMatchPartitionSize).append(";\n");
    builder.append("  private static final String caselessMatchPartitions")
      .append(getVersionSuffix()).append(" =\n");

    // Putting all of the partitions into a set ensures there are no duplicates
    SortedMap<Integer,SortedSet<Integer>> partitions
      = new TreeMap<Integer,SortedSet<Integer>>();
    for (SortedSet<Integer> partition: caselessMatchPartitions.values()) {
      partitions.put(partition.first(), partition);
    }

    int count = 0;
    boolean isFirstPartitionLine = true;
    for (SortedSet<Integer> partition : partitions.values()) {
      if (++count > CASELESS_MATCH_PARTITIONS_PER_LINE) {
        builder.append("\n");
        count = 1;
      }

      if (count == 1)
        builder.append(isFirstPartitionLine ? "        \"" : "      + \"");
      else
        builder.append("+\"");

      isFirstPartitionLine = false;

      for (Integer c : partition)
        emitEscapedUTF16Char(builder, c);

      // Add \u0000 placeholders to fill out the fixed record size
      for (int i = 0 ; i < caselessMatchPartitionSize - partition.size() ; ++i)
        emitEscapedUTF16Char(builder, 0);

      builder.append("\"");
    }
    builder.append(";\n");
  }

  /**
   * Emits an escaped character:
   * <ul>
   *   <li>in form "\\uXXXX", where XXXX is the hexadecimal form of the code
   *       point, if the given point is in the Basic Multilingual Plane (BMP);
   *       or</li>
   *   <li>in form "\\uXXXX\\uYYYY", where XXXX and YYYY are the high and low
   *       surrogates, respectively, representing the given point in UTF-16
   *       form, if the given code point is above the BMP.</li>
   * </ul>
   *
   * @param builder Where to emit the escaped character.
   * @param codePoint The code point for which to emit an escaped character.
   */
  private void emitEscapedUTF16Char(StringBuilder builder, int codePoint) {
    if (codePoint <= 0xFFFF) {
      emitEscapedBMPChar(builder, codePoint);
    } else { // codePoint > 0xFFFF - above the BMP
      if (codePoint < 0x110000) {
        for (char surrogate : Character.toChars(codePoint))
          emitEscapedBMPChar(builder, (int)surrogate);
      } else {
        builder.append("<").append(Integer.toString(codePoint, 16)).append(">");
      }
    }
  }

  /**
   * Emits an escaped character in the form "\\uXXXX", where XXXX is the
   * hexadecimal form of the given code point, which must be in the Basic
   * Multilingual Plane (BMP).  Called from 
   * {@link #emitEscapedUTF16Char(StringBuilder,int)}
   *
   * @param builder Where to emit the escaped character.
   * @param codePoint The code point for which to emit an escaped character.
   */
  private void emitEscapedBMPChar(StringBuilder builder, int codePoint) {
    if (codePoint == 0x22) {
      // Special treatment for the quotation mark (U+0022).  "\u0022" triggers
      // a syntax error when it is included in a literal string, because it is 
      // interpreted as "[...]"[...]" (literally), and leads the compiler to
      // think that the enclosing quotation marks are unbalanced.
      builder.append("\\\"");
    } else if (codePoint == 0x0) { // similarly, these others avoid syntax errs
      builder.append("\\000");
    } else if (codePoint == 0x9) {
      builder.append("\\t");
    } else if (codePoint == 0xA) {
      builder.append("\\n");
    } else if (codePoint == 0xC) {
      builder.append("\\f");
    } else if (codePoint == 0xD) {
      builder.append("\\r");
    } else {
      builder.append("\\u");
      String hexCodePoint = Integer.toString(codePoint, 16);
      for (int i = 0 ; i < 4 - hexCodePoint.length() ; ++i) {
        builder.append('0');
      }
      builder.append(hexCodePoint);
    }
  }

  /**
   * Returns an identifier suffix based on the Unicode major.minor version,
   * substituting an underscore for the period, and with a leading underscore,
   * for use in naming versioned Unicode data in the generated
   * UnicodeProperties.java.
   *
   * @return "_X_Y", where X = major version, and Y = minor version.
   */
  String getVersionSuffix() {
    return "_" + majorMinorVersion.replace(".", "_");
  }

  /**
   * Transforms mixed case identifiers containing spaces, hyphens, and/or
   * underscores by downcasing and removing all spaces, hyphens and underscores.
   *
   * @param identifier The identifier to transform
   * @return The transformed identifier
   */
  String normalize(String identifier) {
    if (null == identifier)
      return identifier;
    String normalized
      = WORD_SEP_PATTERN.matcher(identifier.toLowerCase()).replaceAll("");
    return normalized.replace(':', '=');
  }

  /**
   * Internal-use class to represent code point intervals.
   */
  private class Interval implements Comparable<Interval> {
    int start;
    int end;
    String name;

    Interval(int start, int end) {
      this.start = start;
      this.end = end;
    }

    Interval(int start, int end, String name) {
      this.start = start;
      this.end = end;
      this.name = name;
    }

    public boolean equals(Interval other) {
      boolean isEqual = false;
      if (null != other) {
        isEqual = this == other
                  || (start == other.start && end == other.end
                      && ((null == name && null == other.name)
                          || (null != name && null != other.name
                              && name.equals(other.name))));
      }
      return isEqual;
    }

    public int compareTo(Interval other) {
      int comparison = 0;
      if (null != other && this != other && ! this.equals(other)) {
        comparison = (new Integer(start)).compareTo(other.start);
        if (0 == comparison) {
          comparison = (new Integer(end)).compareTo(other.end);
        }
      }
      return comparison;
    }
  }
}
